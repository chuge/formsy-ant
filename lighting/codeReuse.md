# 代码复用

## 代码复用几条准则

### DRY 原则，不要重复自己的代码

编写代码时，意识到某块逻辑出现重复时，就应该考虑复用**而不是去复制**了。复制过来的代码逻辑，会使得重复的逻辑维护成本变高不少（最直接地修改多个相同逻辑的地方造成遗漏）。

**任何时候，复制代码都是最差的实践**。
常用的业务场景中，有下面的几种通用的复用形式

#### 使用常量和枚举

在常量和枚举章节中讲到，多个相同含义的硬编码，会使得这些硬编码改变时，需要修改多处，而一处遗漏很可能就会带来 BUG。

使用常量来取代硬编码，当需求变动时，只需要修改常量，其它引用常量的代码便能按预期运行。
枚举同理。

#### 请求参数复用

在同一业务中，一些接口的请求参数相似，便将获得从 state 衍生的请求参数的方法抽离成一个类似`getRequestParams`的方法，供多处调用。对于些许的差异，可以通过`getRequestParams`的参数来区分。

#### Ajax 请求方法复用

强烈建议使用 [mobx-ajax-util](https://github.com/tuia-fed/mobx-ajax-util)

#### 工具方法复用

封装后放到`src/lib`下。请用 jsdoc 写好公共方法参数类型，含义，例子等说明。

#### 公共组件复用

请保证公共组件的健壮性，特别是他的 props 能适用于各种业务场景。
放在`src/components`下

### 一个类、方法、组件只做一件事

使得模块、方法只做一件事。
举个最常见的例子。

在写 React 时，我们通常不会把整个需求的所有业务代码写在一个组件里。
如果这么做，会带来下面的问题

1. 这个组件的代码会非常长，1000 行是至少的
2. 维护超长的代码带来的心智负担，比起维护多个组件高出几个数量级
3. ~会被后续的维护者”嘴角抹蜜，口吐芬芳“~

人的大脑一次能够处理和掌控的代码是有限的。拆分代码，把代码分为各个不同的组件，本质上是一种分而治之的思想。如果代码的每一逻辑的部分能够稳定运行，容易维护，那么由他们组成的应用大概率也是健壮而易维护的。

一般来说，我们书写一个业务时，会将代码从逻辑上分为下面几部分

#### 请求层

服务 Ajax 请求的模块，决定了如何发起请求，包含请求参数序列化，请求头等配置。一般业务代码中不会去写这层，只会调用这层。

#### 状态层

状态层是业务的`store.js`（推荐）或者 container 的 state（我们的业务场景复杂，使用 container + components 会导致传参过深）

1. 代表组件的 UI 状态，对于相同的 State，他们必须渲染出相同的视图
2. 组件上的回调被触发时，与状态相关的行为，比如，设置 loading 状态
3. 从组建状态衍生请求参数，供发起 Ajax 请求时使用
4. 调用请求层模块，发起 Ajax 请求，并将状态设置到 state 中

#### 界面层

1. 以状态层参数为输入，输出一个视图。它是一个纯函数，确定的输入一定有确定的输出。
2. 界面层可以有他下面的子界面层，但不推荐层数过深，因为会导致 props 向下传递成本增加。
3. 除此之外不做任何其它事情

#### 工具层

此层代码一般在公共的 utils.js 或者业务代码目录下的 utils.js 中，抽离一些与状态层无关的方法，到这个文件中。
比如：在前端提取 Excel 中的表格信息，从某个状态生成复杂的字符串用于展示等。

## 在仔细评估价值后，使用社区成熟的开源组件库

举个例子，网上有无数这样的关于 deep copy 的实现。但这个 deepCopy 的鲁棒性并不高。
当一个对象内部有循环引用的时候，就会导致这个方法的死循环

```js
var syb = Symbol('obj');
var person = {
  name: 'tino',
  say: function() {
    console.log('hi');
  },
  ok: syb,
  un: undefined
};
var copy = JSON.parse(JSON.stringify(person));
```

社区成熟的方案是 lodash 的`cloneDeep`。

https://lodash.com/docs/4.17.10#cloneDeep

他的实现在这里。

https://github.com/lodash/lodash/blob/master/.internal/baseClone.js

显然，原先的实现就[too young too simple](https://zh.wikipedia.org/zh-hans/%E6%B1%9F%E6%B3%BD%E6%B0%91%E6%80%92%E6%96%A5%E9%A6%99%E6%B8%AF%E8%AE%B0%E8%80%85)了。

**对于 Star 过千，测试完备（测试覆盖率高）的组件库，我们可以认为他基本上是能满足业务需要且安全的**
